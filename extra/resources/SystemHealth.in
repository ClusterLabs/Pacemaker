#!/bin/sh
#
# ocf:pacemaker:SystemHealth resource agent
#
# Copyright 2009-2022 the Pacemaker project contributors
#
# The version control history for this file may have further details.
#
# This source code is licensed under the GNU General Public License version 2
# (GPLv2) WITHOUT ANY WARRANTY.
#

#######################################################################
# Initialization:

: ${OCF_FUNCTIONS:="${OCF_ROOT}/resource.d/heartbeat/.ocf-shellfuncs"}
. "${OCF_FUNCTIONS}"
: ${__OCF_ACTION:="$1"}

daemon_name="ipmiservicelogd"
pidfile="@runstatedir@/ipmiservicelogd.pid0"

# Defaults
OCF_RESKEY_program_default="/usr/sbin/notifyServicelogEvent"
OCF_RESKEY_conn_type_default="smi"
OCF_RESKEY_smi_num_default="0"
OCF_RESKEY_host_default=""
OCF_RESKEY_username_default=""
OCF_RESKEY_password_default=""
OCF_RESKEY_port_default=""
OCF_RESKEY_extra_conn_parms_default=""

: ${OCF_RESKEY_program=${OCF_RESKEY_program_default}}
: ${OCF_RESKEY_conn_type=${OCF_RESKEY_conn_type_default}}
: ${OCF_RESKEY_smi_num=${OCF_RESKEY_smi_num_default}}
: ${OCF_RESKEY_host=${OCF_RESKEY_host_default}}
: ${OCF_RESKEY_username=${OCF_RESKEY_username_default}}
: ${OCF_RESKEY_password=${OCF_RESKEY_password_default}}
: ${OCF_RESKEY_port=${OCF_RESKEY_port_default}}
: ${OCF_RESKEY_extra_conn_parms=${OCF_RESKEY_extra_conn_parms_default}}

#######################################################################

meta_data() {
    cat <<END
<?xml version="1.0"?>
<resource-agent name="SystemHealth" version="1.1">
<version>1.1</version>

<longdesc lang="en">
This is a SystemHealth Resource Agent.  It is used to monitor
the health of a system via IPMI.
</longdesc>
<shortdesc lang="en">SystemHealth resource agent</shortdesc>

<parameters>
<parameter name="program">
<longdesc lang="en">Path to notifyServicelogEvent command</longdesc>
<shortdesc lang="en">Path to notify command</shortdesc>
<content type="string" default="/usr/sbin/notifyServicelogEvent"/>
</parameter>

<parameter name="conn_type">
<longdesc lang="en">
Type of OpenIPMI connection to use, from openipmi_conparms
</longdesc>
<shortdesc lang="en">Type of IPMI connection to use</shortdesc>
<content type="string" default="smi"/>
</parameter>

<parameter name="smi_num">
<longdesc lang="en">
The SMI interface for the local connection. There may be more than one BMC
connection on a system and they are generally numbered, like /dev/ipmi0,
/dev/ipmi1, etc.

Used with conn_type="smi".
</longdesc>
<shortdesc lang="en">The SMI interface for the local connection</shortdesc>
<content type="integer" default="0"/>
</parameter>

<parameter name="host">
<longdesc lang="en">
The IP address (either by name lookup or specified directly) to connect to.

Used with conn_type="lan".
</longdesc>
<shortdesc lang="en">The address for the LAN connection</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="username">
<longdesc lang="en">
Use the given username for the LAN connection. If none is given, then no
username is used.

Used with conn_type="lan".
</longdesc>
<shortdesc lang="en">The username for the LAN connection</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="password">
<longdesc lang="en">
The password to use for the connection. If none is given, the user is assumed to
have an empty password.

Used with conn_type="lan".
</longdesc>
<shortdesc lang="en">The password for the LAN connection</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="port">
<longdesc lang="en">
The UDP port to connect to. This defaults to the standard 623 port, so it is not
necessary unless a special port is required.

Used with conn_type="lan".
</longdesc>
<shortdesc lang="en">The UDP port for the LAN connection</shortdesc>
<content type="string" default=""/>
</parameter>

<parameter name="extra_conn_parms">
<longdesc lang="en">
Extra connection parameters to pass to the ipmiservicelogd daemon. See the
openipmi_conparms(7) man page for available options.
</longdesc>
<shortdesc lang="en">Extra connection parameters</shortdesc>
<content type="string" default=""/>
</parameter>
</parameters>

<actions>
<action name="start"        timeout="20s" />
<action name="stop"         timeout="20s" />
<action name="monitor"      timeout="20s" />
<action name="meta-data"    timeout="5s" />
<action name="validate-all" timeout="20s" />
</actions>
</resource-agent>
END
}

#######################################################################

SystemHealth_usage() {
    cat <<END
usage: $0 {start|stop|monitor|validate-all|meta-data}

Expects to have a fully populated OCF RA-compliant environment set.
END
}

SystemHealth_start() {
    SystemHealth_monitor
    RC=$?

    if [ $RC -eq $OCF_ERR_GENERIC ]; then
        return $OCF_ERR_GENERIC
    elif [ $RC -eq $OCF_SUCCESS ]; then
        ocf_log warn "starting an already started SystemHealth"
        return $OCF_SUCCESS
    fi

    service ipmi start > /dev/null 2>&1
    RC=$?

    if [ $RC -ne 0 ]; then
        ocf_log err "Could not start service IPMI!"
        return $OCF_ERR_GENERIC
    fi

    options=""
    case "$OCF_RESKEY_conn_type" in
        smi)
            options="$smi_num"
            ;;
        lan)
            if [ -n "$OCF_RESKEY_username" ]; then
                options="$options -U $OCF_RESKEY_username"
            fi
            if [ -n "$OCF_RESKEY_password" ]; then
                options="$options -P $OCF_RESKEY_password"
            fi
            if [ -n "$OCF_RESKEY_port" ]; then
                options="$options -p $OCF_RESKEY_port"
            fi
            options="$options $OCF_RESKEY_host"
            ;;
        *)
            ;;
    esac
    options="$options $OCF_RESKEY_extra_conn_parms"

    "$daemon_name" "$OCF_RESKEY_conn_type" $options >/dev/null 2>&1 &
    RC=$?

    if [ $RC -ne 0 ]; then
        ocf_log err "Could not start $daemon_name!"
        return $OCF_ERR_GENERIC
    fi

    servicelog_notify --add --type=EVENT --command="$OCF_RESKEY_program" --method=num_arg --match='type=4' > /dev/null 2>&1
    RC=$?

    if [ $RC -ne 0 ]; then
        ocf_log err "servicelog_notify register handler failed!"
        return $OCF_ERR_GENERIC
    fi

    return $OCF_SUCCESS
}

SystemHealth_stop() {
    SystemHealth_monitor
    RC=$?

    if [ $RC -eq $OCF_ERR_GENERIC ]; then
        return $OCF_ERR_GENERIC
    elif [ $RC -eq  $OCF_SUCCESS ]; then
        killall "$daemon_name"
        RC1=$?

        if [ $RC1 -ne 0 ]; then
            ocf_log err "Could not stop $daemon_name!"
        fi

        servicelog_notify --remove --command="$OCF_RESKEY_program" > /dev/null 2>&1
        RC2=$?

        if [ $RC2 -ne 0 ]; then
            ocf_log err "servicelog_notify remove handler failed!"
        fi

        if [ $RC1 -eq 0 ] && [ $RC2 -eq 0 ]; then
            return $OCF_SUCCESS
        else
            return $OCF_ERR_GENERIC
        fi
    elif [ $RC -eq $OCF_NOT_RUNNING ]; then
        ocf_log warn "stopping an already stopped SystemHealth"
        return $OCF_SUCCESS
    else
        ocf_log err "SystemHealth_stop: should not be here!"
        return $OCF_ERR_GENERIC
    fi
}

SystemHealth_monitor() {
    # Monitor _MUST!_ differentiate correctly between running
    # (SUCCESS), failed (ERROR) or _cleanly_ stopped (NOT RUNNING).
    # That is THREE states, not just yes/no.

    if [ ! -f "$pidfile" ]; then
        ocf_log debug "$daemon_name is not running!"
        return $OCF_NOT_RUNNING
    fi

    pid=$(cat $pidfile | tr -d '[:space:]')

    comm=$(ps -p "$pid" -o comm= 2>/dev/null)
    RC=$?

    if [ $RC -ne 0 ] || [ "$comm" != "$daemon_name" ]; then
        ocf_log debug "${daemon_name} is not running as pid $pid!"
        rm "$pidfile"

        if [ "$__OCF_ACTION" = "monitor" ] && ! ocf_is_probe; then
            return $OCF_ERR_GENERIC
        fi
        return $OCF_NOT_RUNNING
    fi

    servicelog_notify --list --command="$OCF_RESKEY_program" > /dev/null 2>&1
    RC=$?

    if [ $RC -eq 0 ]; then
        return $OCF_SUCCESS
    else
        return $OCF_NOT_RUNNING
    fi
}

SystemHealth_validate() {
    case "$OCF_RESKEY_conn_type" in
        smi)
            num="$OCF_RESKEY_smi_num"
            if ! [ "$num" -eq "$num" ] 2>/dev/null; then
                ocf_exit_reason "smi_num must be an integer"
                return $OCF_ERR_CONFIGURED
            fi
            ;;
        lan)
            if [ -z "$OCF_RESKEY_host" ]; then
                ocf_exit_reason "host parameter must be specified"
                return $OCF_ERR_CONFIGURED
            fi
            ;;
        *)
            ;;
    esac

    if [ $__OCF_ACTION = "start" ] || [ "$OCF_CHECK_LEVEL" -eq 10 ]; then
        check_binary servicelog_notify
        check_binary "$daemon_name"
        check_binary "$OCF_RESKEY_program"
    fi
    return $OCF_SUCCESS
}

case "$__OCF_ACTION" in
start)          SystemHealth_validate; SystemHealth_start;;
stop)           SystemHealth_stop;;
monitor)        SystemHealth_validate; SystemHealth_monitor;;
validate-all)   SystemHealth_validate;;
meta-data)      meta_data; exit $OCF_SUCCESS;;
usage|help)     SystemHealth_usage; exit $OCF_SUCCESS;;
*)              SystemHealth_usage; exit $OCF_ERR_UNIMPLEMENTED;;
esac
rc=$?
ocf_log debug "${OCF_RESOURCE_INSTANCE} $__OCF_ACTION : $rc"
exit $rc

# vim: set filetype=sh expandtab tabstop=4 softtabstop=4 shiftwidth=4 textwidth=80:
